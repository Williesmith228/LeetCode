# 思路一：正向思维

- 既然是将数组前面的位置 全部赋值为不重复的元素，那么，判断条件就是：
当前位置的值 等不等于 其前一个 位置的 值,如果不想等，就是一个不重复的元素，如果相等，则是。

- 我们将数组从1号位置开始遍历，一直到长度减1，因为数组有序，那么0号位置元素肯定不用动, 设置最终的数组，从第1位 final_index 开始。
```
    final_index = 1
    for i in range(1, lenNums):
        if nums[i] != nums[i-1]:
            nums[final_index] = nums[i]
            final_index += 1
    return final_index
``` 
# 逆向思维
- 既然数组前面的位置，最终都会被不重复的元素覆盖，那么实际最终数组后面剩下的都是重复的元素，那么，我们是不是可以从后往前面判断呢？
当遍历到当前位置元素与前面元素不想等时，保留当前位置，当当前位置元素与前面位置元素重复，则删除当前位置元素，举例：[1,1,1,2,2,3]
第一次遍历到nums[5]=3这个元素，因为3!=2, 则保留，这次遍历结束：[1,1,1,2,2,3]
第二次遍历到nums[4]=2这个元素，因为2==2, 则删掉nums[4]=2, 这次遍历结束：[1,1,1,2,3]
第三次遍历到nums[3]=2这个元素，因为2!=1, 则保留nums[3]=2, 这次遍历结束：[1,1,1,2,3]
第四次遍历到nums[2]=1这个元素，因为1==1, 则删除nums[2]=1, 这次遍历结束：[1,1,2,3]
第五次遍历到nums[1]=1这个元素，因为1==1, 则删除nums[1]=1, 这次遍历结束：[1,2,3]
结束
```
    for i in range(lenNums-1,1,-1):
        if nums[i] == nums[i-1]:
            del nums[i]
    return nums
```
